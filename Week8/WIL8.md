> IoC
- Inversion Of Control. "제어의 역전"
- 메소드나 객체의 호출 작업 등 프로그램의 제어 흐름을 개발자가 결정하는 것이 아니라 외부에서 결정되는 것을 의미한다.

> 프레임 워크
- Frame(틀) + Work(일하다) -> 뼈대를 가지고 일하다. (제공 받은 일정한 요소와 틀, 규약을 가지고 무언가를 만드는 일)
- 특정 프로그램을 개발하기 위한 여러 요소들과 메뉴얼인 룰을 제공하는 프로그램
- 대부분의 프레임 워크에서 IoC를 적용한다.

* 이를 사용했을 경우 생산성을 높여주는 이유
(1) 뼈대를 제공하고 이에 개발자가 코드를 올려 동작하게 함
(2) 시스템을 일관성 있게 관리 가능
(3) 시스템의 유지/보수가 용이

> 라이브러리
- 소프트웨어를 개발하기 쉽게 어떤 기능을 제공하는 도구들
- 프레임 워크와 "자유도" 측면에서 다르다. 프레임 워크는 필수로 써야 되는 것들과 지켜야 하는 룰이 있지만, 라이브러리는 그런 게 없다.

> 생성자를 통한 의존성 주입과 @Autowired 비교
- 주입: "외부에서"라는 뜻을 내포
- 의존관계 주입: 외부로부터 메모리에 올라가있는 인스턴스의 레퍼런스를 인터페이스 타입의 파라미터로 의존관계를 설정하는 것.
- 생성자를 통한 의존성 주입: 생성자를 통홰 의존 관계를 주입하는 방법. 인터페이스를 구현(준수)했기에 코드 재컴파일과 재배포에 대한 부담을 덜 수 있다.

- @Autowired: 주입하려고 하는 객체의 타입이 일치하는 객체를 자동으로 주입. 해당 어노테이션을 필드에 부여하면 IoC 컨테이너 안에 존재하는 특정 필드와 같은 타입의 Bean을 찾아 자동으로 주입한다. 3종류로 필드 주입, 생성자 주입, setter 주입이 있다.

* 생성자를 통한 의존성 주입 vs. @Autowired
- @Autowired를 사용하면 단위 테스트가 아닐 뿐만 아니라, 컴포넌트들을 등록하고 초기화하는 시간으로 인해 테스트 비용이 증가하게 된다. 반면, 생성자를 통한 의존성 주입을 사용한다면 컴파일 시점에 객체를 주입 받아 테스트 코드를 작성할 수 있다.
- @Autowired를 이용한다면 순환 참조 문제가 애플리케이션 구동 시점에서 에러가 발생하지 않아 해당 메소드 호출 시 stackover로 인해 서버가 죽게 된다. 그러나 생성자를 통한 의존성 주입을 이용한다면, 객체의 생성과 의존관계 주입이 동시에 실행되기 때문에 컴파일 시점에 이와 같은 에러를 잡을 수 있다.

> AOP
- Aspect-Oriented Programming
- 핵심 로직과 부가 기능을 분리하여 애플리케이션 전체에 걸쳐 사용되는 부가 기능을 모듈화하여 재사용할 수 있도록 지원하는 것.
- 기존의 OOP(비즈니스 로직의 모듈화)에서 바라보던 관점과 다르게 부가기능적은 측면에서 보았을 때의 공통된 요소를 추출.
